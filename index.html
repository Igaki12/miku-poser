<!DOCTYPE html>
<html lang="en">

<head>
	<title>Miku POSER Ver.1.0 Mediapipe PoseLandmaker x Three.js MMDLoader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="three.js-master/examples/main.css">
	<style>
		body {
			background-color: #fff;
			color: #444;
			font-family: roboto;
			margin: 2em;
			--mdc-theme-primary: #007f8b;
			--mdc-theme-on-primary: #f1f3f4;
		}

		a {
			color: #08f;
		}

		h1 {
			color: #007f8b;
		}

		h2 {
			clear: both;
		}

		em {
			font-weight: bold;
		}

		video {
			clear: both;
			display: block;
			transform: rotateY(180deg);
			-webkit-transform: rotateY(180deg);
			-moz-transform: rotateY(180deg);
		}

		section {
			opacity: 1;
			transition: opacity 500ms ease-in-out;
		}

		header,
		footer {
			clear: both;
		}

		.removed {
			display: none;
		}

		.invisible {
			opacity: 0.2;
		}

		.note {
			font-style: italic;
			font-size: 130%;
		}

		.videoView,
		.detectOnClick {
			position: relative;
			float: left;
			width: 48%;
			margin: 2% 1%;
			cursor: pointer;
		}

		.videoView p,
		.detectOnClick p {
			position: absolute;
			padding: 5px;
			background-color: #007f8b;
			color: #fff;
			border: 1px dashed rgba(255, 255, 255, 0.7);
			z-index: 2;
			font-size: 12px;
			margin: 0;
		}

		.highlighter {
			background: rgba(0, 255, 0, 0.25);
			border: 1px dashed #fff;
			z-index: 1;
			position: absolute;
		}

		.canvas {
			z-index: 1;
			position: absolute;
			pointer-events: none;
		}

		.output_canvas {
			transform: rotateY(180deg);
			-webkit-transform: rotateY(180deg);
			-moz-transform: rotateY(180deg);
		}

		.detectOnClick {
			z-index: 0;
		}

		.detectOnClick img {
			width: 100%;
		}

		/* 一般的なtableデザイン */
		table {
			border-collapse: collapse;
			width: 100%;
			margin: 0 auto;
		}

		table th {
			background-color: #072300;
			color: #fff;
			font-weight: bold;
			text-align: center;
			border: 1px solid #ccc;
			padding: 8px;
		}

		table td {
			border: 1px solid #ccc;
			padding: 8px;
			background-color: white;
			text-align: center;
		}

		th.sort-asc::after {
			content: " ▲";
		}

		th.sort-desc::after {
			content: " ▼";
		}

		/* input  type file のボタン */
		input[type="file"] {
			background-color: #007f8b;
			color: #fff;
			border: none;
			padding: 10px 20px;
			border-radius: 5px;
			cursor: pointer;
		}

		input[type="file"]:disabled {
			background-color: #ddd;
			cursor: not-allowed;
		}

		.disabled-label {
			opacity: 0.5;
			cursor: not-allowed;
		}

		p,
		label {
			font:
				1rem 'Fira Sans',
				sans-serif;
		}

		input {
			margin: 0.4rem;
		}
		.rainbow-button {
			background: linear-gradient(45deg, #134d00, #007f8b, #ff0000, #ff00ff, #ff0000, #007f8b, #134d00);
			background-size: 400%;
			margin: 10px auto;
			color: white;
			font-size: large;
			font-weight: bold;
			border: none;
			padding: 10px 20px;
			border-radius: 5px;
			cursor: pointer;
			animation: rainbow 3s linear infinite;
		}
	</style>

	<!-- mediapipe-comparison : https://igaki12.github.io/mediapipe-comparison からコピー -->
	<!-- <link rel="stylesheet" href="index.css"> -->
	<!-- <script type="module" src="index.js"></script> -->
	<link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
	<script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
</head>

<body>
	<script type="importmap">
		{
			"imports": {
				"three": "./three.js-master/build/three.module.js",
				"three/addons/": "./three.js-master/examples/jsm/"
			}
		}
	</script>
	<section id="mediapipe-section">
		<h1>Pose detection using the MediaPipe PoseLandmarker task</h1>
		<p id="loadingMsg">モジュールの読み込みに数秒かかります...</p>
		<section id="demos" class="invisible">


			<!-- 手持ちの画像をアップする仕組み -->
			<h2>Comparison:<br>2枚の画像のPoseを比較</h2>
			<p>あなたの画像をアップロードして、以前の画像と姿勢を比較することができます</p>
			<p>推奨環境：Google Chrome</p>
			<p>以前の画像 (サンプル画像/比較元) ▽</p>
			<div style="display: flex; justify-content: center; gap: 0px; margin-left: -2em; margin-right: -2em;">
				<img src="./sample.jpg" id="image_before" width="50%"
					style="position: block; background-color: #007f8b;">
				<canvas id="canvas_overlay" width="50%" style="position: absolute; "></canvas>
				<canvas id="canvas_before" width="50%" style="position: block; background-color: #007f8b;"></canvas>
			</div>



			<!-- 骨格画像をダウンロードする仕組み：https://qiita.com/lookman/items/d93dd62a41f17a4d2de8 -->
			<a id="download_canvas_before" style="display: none;">骨格画像をダウンロード</a>
			<!-- サンプル画像をcanvasに描画する仕組み: https://www.g-u-k.jp/take_log/archives/826 drawImage()を使う -->
			<canvas id="sample_img_canvas" width="100%" style="display: none;"></canvas>
			<a id="download_sample_img_canvas" style="display: none;">この骨格画像をダウンロード</a>
			<br>

			<p id="loadingMsg2"></p>
			<input type="file" accept="image/*" id="fileSelector" disabled />

			<div id="selectedImageDiv">
				<img id="selectedImage" width="100%" crossorigin="anonymous" loading="lazy" />
				<canvas id="canvas_after" width="100%"
					style="position: absolute; transition: opacity 1s; display: none;"></canvas>
				<canvas id="canvas_after_overlay" width="100%"
					style="position: absolute; transition: opacity 1s; display: none;"></canvas>
				<canvas id="canvas_auxiliary" width="100%"
					style="position: absolute; transition: opacity 1s; display: none;"></canvas>
				<canvas id="canvas_auxiliary_after" width="100%"
					style="position: absolute; transition: opacity 1s; display: none;"></canvas>
			</div>

			<canvas id="download_canvas" style="display: none;"></canvas>
			<a id="download_canvas_after" style="display: none;">この骨格画像をダウンロード</a>
			<br>

			<!-- checkboxのリスト -->
			<fieldset id="checkboxes"
				style="display: none; justify-content: left; gap: 1em; border: 1px solid #007f8b; margin-bottom: 10px; margin-top: 0px; flex-wrap: wrap;">
				<legend>レイヤ表示</legend>

				<div>
					<!-- checkboxの背景色をオレンジにする -->
					<input type="checkbox" id="checkbox_before" name="checkbox_before" checked
						style="background-color: orange;" />

					<label for="checkbox_before">姿勢予測(前)</label>
				</div>

				<div>
					<input type="checkbox" id="checkbox_after" name="checkbox_after" checked />
					<label for="checkbox_after">姿勢予測(後)</label>
				</div>

				<div>
					<input type="checkbox" id="checkbox_auxiliary" name="checkbox_auxiliary" checked />
					<label for="checkbox_auxiliary">補助線(前)</label>
				</div>
				<div>
					<input type="checkbox" id="checkbox_auxiliary_after" name="checkbox_auxiliary_after" checked />
					<label for="checkbox_auxiliary_after">補助線(後)</label>
				</div>
			</fieldset>


			<table id="worldLandmarksTable">
				<tr>
					<th rowspan="2">部位 (番号) </th>
					<th rowspan="2">角度（ °）</th>
					<th colspan="4">Quaternion</th>
				</tr>
				<tr>
					<th>X</th>
					<th>Y</th>
					<th>Z</th>
					<th>W</th>
				</tr>
			</table>
			<button id="switchSection" style="display: none;" class="rainbow-button">MMDLoaderを起動</button>
			<script>
				document.getElementById('switchSection').addEventListener('click', function () {
					document.getElementById('mediapipe-section').style.display = 'none';
					document.getElementById('mmd-loader-container').style.display = '';
					document.getElementById('mmdloader-section').style.display = '';
				});
			</script>
		</section>
	</section>
	<section id="mmdloader-section" style="display: none;">
		<div id="info">
			<button id="reswitchSection" class="rainbow-button">MMDLoaderを終了</button>
			<script>
				document.getElementById('reswitchSection').addEventListener('click', function () {
					document.getElementById('mediapipe-section').style.display = '';
					document.getElementById('mmd-loader-container').style.display = 'none';
					document.getElementById('mmdloader-section').style.display = 'none';
				});
			</script>
			<input type="number" id="poseName" value="17" step="1" style="margin: 1px; display: none;" /><br><span id="poseNameText">左肩</span><br>
			<input type="number" id="poseX" value="0" step="0.1" style="margin: 1px; display: none;" /><br>
			<input type="number" id="poseY" value="0" step="0.1" style="margin: 1px; display: none;" /><br>
			<input type="number" id="poseZ" value="0" step="0.1" style="margin: 1px; display: none;" /><br>
			<input type="number" id="poseW" value="1" step="0.1" style="margin: 1px; display: none;" /><br>
			<button id="resetPose" style="display: none;">Reset Pose</button><br>
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - MMDLoader test<br />
			<a href="https://github.com/mrdoob/three.js/tree/master/examples/models/mmd#readme" target="_blank"
				rel="noopener">MMD Assets license</a><br />
			Copyright
			<a href="https://sites.google.com/view/evpvp/" target="_blank" rel="noopener">Model Data</a>
			<a href="http://www.nicovideo.jp/watch/sm13147122" target="_blank" rel="noopener">Dance Data</a>
		</div>
	</section>

	<!-- <script src="jsm/libs/ammo.wasm.js"></script> -->
	<!-- こんな感じでファイルの場所を変更し、index.htmlに直してgithubpagesに反映させる -->
	<script src="three.js-master/examples/jsm/libs/ammo.wasm.js"></script>


	<script type="module">

		import {
			PoseLandmarker,
			FilesetResolver,
			DrawingUtils
		} from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

		import * as THREE from 'three';

		import Stats from 'three/addons/libs/stats.module.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { OutlineEffect } from 'three/addons/effects/OutlineEffect.js';
		import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
		import { MMDAnimationHelper } from 'three/addons/animation/MMDAnimationHelper.js';

		// うけわたす関節角度情報をグローバル変数に格納
		let Quaternions = {};


		// ここからmediapipe-comparisonのjsをコード。mediapipe-comparisonのindex.jsから引用
		const demosSection = document.getElementById("demos");

		let poseLandmarker = undefined;
		let runningMode = "IMAGE";
		let imageSegmenter;
		// Before we can use PoseLandmarker class we must wait for it to finish
		// loading. Machine Learning models can be large and take a moment to
		// get everything needed to run.
		const loadingInterval = setInterval(() => {
			document.getElementById("loadingMsg").innerHTML += ".";
			if (document.getElementById("loadingMsg").innerHTML.length > 25) {
				document.getElementById("loadingMsg").innerHTML = "モジュールの読み込みに数秒かかります...";
			}
		}, 1000);

		const createPoseLandmarker = async () => {
			const vision = await FilesetResolver.forVisionTasks(
				"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
			);
			poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
				baseOptions: {
					modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,
					delegate: "GPU"
				},
				runningMode: runningMode,
				numPoses: 2
			});
			demosSection.classList.remove("invisible");
			document.getElementById("loadingMsg").style.display = "none";
			clearInterval(loadingInterval);

			runPoseEstimation();
			// 骨格画像をダウンロードする仕組みを追加
			let download_canvas_before = document.getElementById("download_canvas_before");
			download_canvas_before.href = document.getElementById("canvas_before").toDataURL();
			download_canvas_before.download = "pose_before.png";
			// download_canvas_before.style.display = "";




		};
		createPoseLandmarker();

		const positionNamesJP = [
			"鼻 (nose)",
			"左目-内側 (left eye - inner)",
			"左目 (left eye)",
			"左目-外側 (left eye - outer)",
			"右目-内側 (right eye - inner)",
			"右目 (right eye)",
			"右目-外側 (right eye - outer)",
			"左耳 (left ear)",
			"右耳 (right ear)",
			"口-左縁 (mouth - left)",
			"口-右縁 (mouth - right)",
			"左肩 (left shoulder)",
			"右肩 (right shoulder)",
			"左肘 (left elbow)",
			"右肘 (right elbow)",
			"左手首 (left wrist)",
			"右手首 (right wrist)",
			"左小指 (left pinky)",
			"右小指 (right pinky)",
			"左人差し指 (left index)",
			"右人差し指 (right index)",
			"左親指 (left thumb)",
			"右親指 (right thumb)",
			"左腰 (left hip)",
			"右腰 (right hip)",
			"左膝 (left knee)",
			"右膝 (right knee)",
			"左足首 (left ankle)",
			"右足首 (right ankle)",
			"左かかと (left heel)",
			"右かかと (right heel)",
			"左足先 (left foot index)",
			"右足先 (right foot index)"
		];
		/********************************************************************
		// Demo 1: Grab a bunch of images from the page and detection them
		// upon click.
		********************************************************************/

		// In this demo, we have put all our clickable images in divs with the
		// CSS class 'detectionOnClick'. Lets get all the elements that have
		// this class.

		// すでにアップされている画像を選択して表示し、ポーズ推定を行う
		let result_before = [];
		const image_before = document.getElementById("image_before");
		const canvas_overlay = document.getElementById("canvas_overlay");
		const canvas_before = document.getElementById("canvas_before");
		canvas_overlay.width = image_before.width;
		canvas_overlay.height = image_before.height;
		canvas_overlay.style.top = image_before.offsetTop;
		canvas_overlay.style.left = 0;
		canvas_before.width = image_before.width;
		canvas_before.height = image_before.height;

		// 画像が表示されたら、ポーズ推定を行う
		const runPoseEstimation = () => {
			// image_before.onload = () => {
			console.log("image_before.onload");
			if (!poseLandmarker) {
				console.log("Wait for poseLandmarker to load before clicking!");
				return;
			}

			if (runningMode === "VIDEO") {
				runningMode = "IMAGE";
				poseLandmarker.setOptions({ runningMode: "IMAGE" });
			}
			// poseLandmarker.setOptions({ outputSegmentationMasks: true });



			poseLandmarker.detect(image_before, async (result) => {
				// サンプル画像をcanvasに描画する仕組み: https://www.g-u-k.jp/take_log/archives/826 drawImage()を使う
				const sample_image_src = "./sample.jpg";
				const sample_image = new Image();
				sample_image.src = sample_image_src;
				sample_image.onload = () => {
					const sample_img_canvas = document.getElementById("sample_img_canvas");
					sample_img_canvas.width = sample_image.width;
					sample_img_canvas.height = sample_image.height;
					const sample_img_canvasCtx = sample_img_canvas.getContext("2d");
					sample_img_canvasCtx.drawImage(sample_image, 0, 0);
					// sample_img_canvas.style.display = "";
					// この画像に骨格画像を重ねる


					const canvas_overlayCtx = canvas_overlay.getContext("2d");
					const canvas_beforeCtx = canvas_before.getContext("2d");
					const drawingUtils_overlay = new DrawingUtils(canvas_overlayCtx);
					const drawingUtils_before = new DrawingUtils(canvas_beforeCtx);
					const DrawingUtils_sample = new DrawingUtils(sample_img_canvasCtx);
					for (const landmark of result.landmarks) {
						drawingUtils_overlay.drawLandmarks(landmark, {
							radius: (data) => DrawingUtils.lerp(data.from?.z ?? 0, -0.15, 0.1, 5, 1),
							lineWidth: 2,
						});
						drawingUtils_before.drawLandmarks(landmark, {
							radius: (data) => DrawingUtils.lerp(data.from?.z ?? 0, -0.15, 0.1, 5, 1),
							lineWidth: 2,
						});
						DrawingUtils_sample.drawLandmarks(landmark, {
							radius: (data) => DrawingUtils.lerp(data.from?.z ?? 0, -0.15, 0.1, 5, 1),
							lineWidth: 2,
						});
						drawingUtils_overlay.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS,
							{ lineWidth: 2, color: "white" });
						drawingUtils_before.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS,
							{ lineWidth: 2, color: "white" });
						DrawingUtils_sample.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS,
							{ lineWidth: 2, color: "white" });
					}



					result_before = result;
					console.log("result_before : ");
					console.log(result_before);
					document.getElementById("fileSelector").disabled = false;
					document.getElementById("loadingMsg2").innerText = "比較したい画像を選択してください▽";

					// sample_img_canvasをダウンロードする仕組みを追加
					let download_sample_img_canvas = document.getElementById("download_sample_img_canvas");
					download_sample_img_canvas.href = sample_img_canvas.toDataURL();
					download_sample_img_canvas.download = "pose_sample.png";
					download_sample_img_canvas.style.display = "";

				};
			})
		};


		// 手持ちの画像を選択して表示し、ポーズ推定を行う

		const FileSelector = document.getElementById("fileSelector");
		const image_after = document.getElementById("selectedImage");
		const canvas_after = document.getElementById("canvas_after");
		const canvas_after_overlay = document.getElementById("canvas_after_overlay");
		const download_canvas = document.getElementById("download_canvas");

		let result_after = [];
		FileSelector.addEventListener("change", (event) => {
			const file = event.target.files[0];
			if (!file) {
				return;
			}
			const reader = new FileReader();
			reader.onload = (e) => {
				image_after.src = e.target.result;
			};
			reader.readAsDataURL(file);
			// 画像が表示されたら、ポーズ推定を行う
			image_after.onload = () => {
				canvas_after.style.display = "";
				canvas_after.width = image_after.width;
				canvas_after.height = image_after.height;
				canvas_after.style.top = image_after.width;
				canvas_after.style.left = "2em";
				canvas_after_overlay.style.display = "";
				canvas_after_overlay.width = image_after.width;
				canvas_after_overlay.height = image_after.height;
				canvas_after_overlay.style.top = image_after.width;
				canvas_after_overlay.style.left = "2em";
				const canvas_auxiliary = document.getElementById("canvas_auxiliary");
				canvas_auxiliary.style.display = "";
				canvas_auxiliary.width = image_after.width;
				canvas_auxiliary.height = image_after.height;
				canvas_auxiliary.style.top = image_after.width;
				canvas_auxiliary.style.left = "2em";
				const canvas_auxiliary_after = document.getElementById("canvas_auxiliary_after");
				canvas_auxiliary_after.style.display = "";
				canvas_auxiliary_after.width = image_after.width;
				canvas_auxiliary_after.height = image_after.height;
				canvas_auxiliary_after.style.top = image_after.width;
				canvas_auxiliary_after.style.left = "2em";
				download_canvas.width = image_after.width;
				download_canvas.height = image_after.height;
				download_canvas.style.top = image_after.width;
				download_canvas.style.left = "2em";
				// img内容をcanvasに描画する
				const download_canvasCtx = download_canvas.getContext("2d");
				download_canvasCtx.drawImage(image_after, 0, 0, image_after.width, image_after.height);

				if (!poseLandmarker) {
					console.log("Wait for poseLandmarker to load before clicking!");
					return;
				}

				if (runningMode === "VIDEO") {
					runningMode = "IMAGE";
					poseLandmarker.setOptions({ runningMode: "IMAGE" });
				}
				poseLandmarker.detect(image_after, async (result) => {
					const canvas_afterCtx = canvas_after.getContext("2d");
					const drawingUtils_after = new DrawingUtils(canvas_afterCtx);
					const drawingUtils_download = new DrawingUtils(download_canvasCtx);


					for (const landmark of result.landmarks) {
						drawingUtils_after.drawLandmarks(landmark, {
							radius: (data) => DrawingUtils.lerp(data.from?.z ?? 0, -0.15, 0.1, 5, 1),
							// color: "orange",
						});
						drawingUtils_download.drawLandmarks(landmark, {
							radius: (data) => DrawingUtils.lerp(data.from?.z ?? 0, -0.15, 0.1, 5, 1),
							// color: "orange",
						});
						drawingUtils_after.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);
						drawingUtils_download.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);
					}
					if (result.landmarks.length === 0 || result.landmarks[0] == undefined || result.landmarks[0].length < 32) {
						// この後の処理を行わない
						console.log("landmarks is empty");
						return;
					}
					const left_ankle = result.landmarks[0][27];
					const right_ankle = result.landmarks[0][28];
					const ankle_center = {
						x: (left_ankle.x + right_ankle.x) / 2,
						y: (left_ankle.y + right_ankle.y) / 2,
						z: (left_ankle.z + right_ankle.z) / 2
					};
					console.log("ankle_center_after : ");
					console.log(ankle_center);
					// 鼻から足首の中点までの距離(身長に対応する長さ)を求める *Z座標は使わない
					const nose = result.landmarks[0][0];
					const nose_to_ankle_center_XY = Math.sqrt((nose.x - ankle_center.x) ** 2 + (nose.y - ankle_center.y) ** 2);




					if (result_before != [] && result_before.landmarks && result_before.landmarks[0].length > 32) {
						console.log("result_before.landmarks[0].length : ", result_before.landmarks[0].length);
						const canvas_after_overlayCtx = canvas_after_overlay.getContext("2d");
						const drawingUtils_after_overlay = new DrawingUtils(canvas_after_overlayCtx);
						for (const landmark of result_before.landmarks) {
							// 足首の中点の座標を求める
							const left_ankle_before = landmark[27];
							const right_ankle_before = landmark[28];
							const ankle_center_before = {
								x: (left_ankle_before.x + right_ankle_before.x) / 2,
								y: (left_ankle_before.y + right_ankle_before.y) / 2,
								z: (left_ankle_before.z + right_ankle_before.z) / 2
							};
							console.log("ankle_center_before : ");
							console.log(ankle_center_before);
							// 鼻から足首の中点までの距離(身長に対応する長さ)を求める
							const nose_before = landmark[0];
							const nose_to_ankle_center_XY_before = Math.sqrt((nose_before.x - ankle_center_before.x) ** 2 + (nose_before.y - ankle_center_before.y) ** 2);
							// 身長の比を求める
							const height_ratio = nose_to_ankle_center_XY / nose_to_ankle_center_XY_before;
							// before各座標の、足首の中点を基準にして、身長比をかけ、afterの座標に変換する
							const landmark_from_ankle_center_before = landmark.map((point) => {
								return {
									x: (point.x - ankle_center_before.x) * height_ratio + ankle_center.x,
									y: (point.y - ankle_center_before.y) * height_ratio + ankle_center.y,
									z: (point.z - ankle_center_before.z) * height_ratio + ankle_center.z
								};
							});
							// 変換後の座標を描画する
							drawingUtils_after_overlay.drawLandmarks(landmark_from_ankle_center_before, {
								radius: (data) => DrawingUtils.lerp(data.from?.z ?? 0, -0.15, 0.1, 5, 1),
								lineWidth: 2,
								color: "orange",
							});
							drawingUtils_after_overlay.drawConnectors(landmark_from_ankle_center_before, PoseLandmarker.POSE_CONNECTIONS,
								{ lineWidth: 2, color: "orange" });


							// 正中線を描画する
							const canvas_auxiliary_afterCtx = canvas_auxiliary_after.getContext("2d");
							const drawingUtils_auxiliary_after = new DrawingUtils(canvas_auxiliary_afterCtx);

							const shoulder_center = {
								x: (result.landmarks[0][11].x + result.landmarks[0][12].x) / 2,
								y: (result.landmarks[0][11].y + result.landmarks[0][12].y) / 2,
								z: (result.landmarks[0][11].z + result.landmarks[0][12].z) / 2
							}
							const hip_center = {
								x: (result.landmarks[0][23].x + result.landmarks[0][24].x) / 2,
								y: (result.landmarks[0][23].y + result.landmarks[0][24].y) / 2,
								z: (result.landmarks[0][23].z + result.landmarks[0][24].z) / 2
							}
							drawingUtils_auxiliary_after.drawLandmarks([ankle_center, hip_center, shoulder_center, result.landmarks[0][0]], {
								radius: 3,
							});
							drawingUtils_auxiliary_after.drawConnectors([ankle_center, hip_center, shoulder_center, result.landmarks[0][0]], [{ start: 0, end: 1 }, { start: 1, end: 2 }, { start: 2, end: 3 }],
								{ lineWidth: 2 });

							// 補助線を描画する
							const canvas_auxiliaryCtx = canvas_auxiliary.getContext("2d");
							const drawingUtils_auxiliary = new DrawingUtils(canvas_auxiliaryCtx);
							const shoulder_center_before = {
								x: (landmark_from_ankle_center_before[11].x + landmark_from_ankle_center_before[12].x) / 2,
								y: (landmark_from_ankle_center_before[11].y + landmark_from_ankle_center_before[12].y) / 2,
								z: (landmark_from_ankle_center_before[11].z + landmark_from_ankle_center_before[12].z) / 2
							}
							const hip_center_before = {
								x: (landmark_from_ankle_center_before[23].x + landmark_from_ankle_center_before[24].x) / 2,
								y: (landmark_from_ankle_center_before[23].y + landmark_from_ankle_center_before[24].y) / 2,
								z: (landmark_from_ankle_center_before[23].z + landmark_from_ankle_center_before[24].z) / 2
							}

							drawingUtils_auxiliary.drawLandmarks([ankle_center, hip_center_before, shoulder_center_before, landmark_from_ankle_center_before[0]], {
								radius: 3,
								color: "orange",
							});
							drawingUtils_auxiliary.drawConnectors([ankle_center, hip_center_before, shoulder_center_before, landmark_from_ankle_center_before[0]], [{ start: 0, end: 1 }, { start: 1, end: 2 }, { start: 2, end: 3 }],
								{
									lineWidth: 2,
									color: "orange",
								});
							console.log("POSE_CONNECTIONS : ");
							console.log(PoseLandmarker.POSE_CONNECTIONS);


							document.getElementById("checkbox_before").addEventListener("change", () => {
								if (document.getElementById("checkbox_before").checked) {
									canvas_after_overlay.style.opacity = 1;
								} else {
									canvas_after_overlay.style.opacity = 0;
									canvas_auxiliary.style.opacity = 0;
									document.getElementById("checkbox_auxiliary").checked = false;
								}
							});
							document.getElementById("checkbox_after").addEventListener("change", () => {
								if (document.getElementById("checkbox_after").checked) {
									canvas_after.style.opacity = 1;
								} else {
									canvas_after.style.opacity = 0;
									canvas_auxiliary_after.style.opacity = 0;
									document.getElementById("checkbox_auxiliary_after").checked = false;
								}
							});
							document.getElementById("checkbox_auxiliary").addEventListener("change", () => {
								if (document.getElementById("checkbox_auxiliary").checked) {
									canvas_auxiliary.style.opacity = 1;
									canvas_before.style.opacity = 1;
									document.getElementById("checkbox_before").checked = true;
								} else {
									canvas_auxiliary.style.opacity = 0;
								}
							});
							document.getElementById("checkbox_auxiliary_after").addEventListener("change", () => {
								if (document.getElementById("checkbox_auxiliary_after").checked) {
									canvas_auxiliary_after.style.opacity = 1;
									canvas_after.style.opacity = 1;
									document.getElementById("checkbox_after").checked = true;
								} else {
									canvas_auxiliary_after.style.opacity = 0;
								}
							});


							// 1秒おきに3回点滅させる
							let count = 0;
							const setLayerInterval = setInterval(() => {
								count++;
								if (count > 3) {
									clearInterval(setLayerInterval);
								}
								canvas_after_overlay.style.opacity = 1 - canvas_after_overlay.style.opacity;
								canvas_auxiliary.style.opacity = 1 - canvas_auxiliary.style.opacity;
							}, 1000);

							setTimeout(() => {
								document.getElementById("checkboxes").style.display = "flex";
								canvas_after_overlay.style.opacity = 0;
								canvas_auxiliary.style.opacity = 0;
								// ここにdownload_canvas_afterの設定を追加
								let download_canvas_after = document.getElementById("download_canvas_after");
								download_canvas_after.href = document.getElementById("download_canvas").toDataURL();
								download_canvas_after.download = "pose_after.png";
								download_canvas_after.style.display = "";

								// ここに首関節の角度：Quaternion(x,y,z,w)を求める処理を追加
								const nose_worldLandmarks = result.worldLandmarks[0][0];
								const shoulder_center_worldLandmarks = {
									x: (result.worldLandmarks[0][11].x + result.worldLandmarks[0][12].x) / 2,
									y: (result.worldLandmarks[0][11].y + result.worldLandmarks[0][12].y) / 2,
									z: (result.worldLandmarks[0][11].z + result.worldLandmarks[0][12].z) / 2
								}
								const hip_center_worldLandmarks = {
									x: (result.worldLandmarks[0][23].x + result.worldLandmarks[0][24].x) / 2,
									y: (result.worldLandmarks[0][23].y + result.worldLandmarks[0][24].y) / 2,
									z: (result.worldLandmarks[0][23].z + result.worldLandmarks[0][24].z) / 2
								}
								// XY平面上での角度を求める。尻中央-肩中央のベクトルに対する、鼻-肩中央のベクトルの角度
								const angle_XY_neck = Math.atan2(nose_worldLandmarks.y - shoulder_center_worldLandmarks.y, nose_worldLandmarks.x - shoulder_center_worldLandmarks.x) - Math.atan2(shoulder_center_worldLandmarks.y - hip_center_worldLandmarks.y, shoulder_center_worldLandmarks.x - hip_center_worldLandmarks.x);
								// Quaternionを求める 小数点以下第7位で四捨五入する
								const neckQuaternionXY = {
									// テスト
									x: 0,
									y: 0,
									// -1~1の範囲で、90度右に傾くと+0.5、左に傾くと-0.5になるようにする
									z: -1 * Math.round(angle_XY_neck / Math.PI * 1000000) / 1000000,
									w: 1,
								};
								const worldLandmarksTable = document.getElementById("worldLandmarksTable");
								const neckTr = document.createElement("tr");
								const neckTd1 = document.createElement("td");
								const neckTdAngle = document.createElement("td");
								const neckTd2 = document.createElement("td");
								const neckTd3 = document.createElement("td");
								const neckTd4 = document.createElement("td");
								const neckTd5 = document.createElement("td");
								neckTd1.innerText = "首(2)";
								neckTdAngle.innerText = Math.round(angle_XY_neck / Math.PI * 1800) / 10;
								neckTd2.innerText = neckQuaternionXY.x;
								neckTd3.innerText = neckQuaternionXY.y;
								neckTd4.innerText = neckQuaternionXY.z;
								neckTd5.innerText = neckQuaternionXY.w;
								neckTr.appendChild(neckTd1);
								neckTr.appendChild(neckTdAngle);
								neckTr.appendChild(neckTd2);
								neckTr.appendChild(neckTd3);
								neckTr.appendChild(neckTd4);
								neckTr.appendChild(neckTd5);
								worldLandmarksTable.appendChild(neckTr);

								// ここに上半身の角度：Quaternion(x,y,z,w)を求める処理を追加
								shoulder_center_worldLandmarks;
								hip_center_worldLandmarks;
								const ankle_center_worldLandmarks = {
									x: (result.worldLandmarks[0][27].x + result.worldLandmarks[0][28].x) / 2,
									y: (result.worldLandmarks[0][27].y + result.worldLandmarks[0][28].y) / 2,
									z: (result.worldLandmarks[0][27].z + result.worldLandmarks[0][28].z) / 2
								}
								// XY平面上での角度を求める。足首中央-肩中央のベクトルに対する、肩中央-尻中央のベクトルの角度
								const angle_XY_upper_body = Math.atan2(shoulder_center_worldLandmarks.y - hip_center_worldLandmarks.y, shoulder_center_worldLandmarks.x - hip_center_worldLandmarks.x) - Math.atan2(hip_center_worldLandmarks.y - ankle_center_worldLandmarks.y, hip_center_worldLandmarks.x - ankle_center_worldLandmarks.x);
								// Quaternionを求める
								const upperBodyQuaternionXY = {
									x: 0,
									y: 0,
									// -0.7~+0.7の範囲で、右に90度傾く+0.7、左に90度傾く-0.7になるようにする
									z: -1.4 * Math.round(angle_XY_upper_body / Math.PI * 1000000) / 1000000,
									w: 1,
								};
								const upperBodyTr = document.createElement("tr");
								const upperBodyTd1 = document.createElement("td");
								const upperBodyTdAngle = document.createElement("td");
								const upperBodyTd2 = document.createElement("td");
								const upperBodyTd3 = document.createElement("td");
								const upperBodyTd4 = document.createElement("td");
								const upperBodyTd5 = document.createElement("td");
								upperBodyTd1.innerText = "上半身(1)";
								upperBodyTdAngle.innerText = Math.round(angle_XY_upper_body / Math.PI * 1800) / 10;
								upperBodyTd2.innerText = upperBodyQuaternionXY.x;
								upperBodyTd3.innerText = upperBodyQuaternionXY.y;
								upperBodyTd4.innerText = upperBodyQuaternionXY.z;
								upperBodyTd5.innerText = upperBodyQuaternionXY.w;
								upperBodyTr.appendChild(upperBodyTd1);
								upperBodyTr.appendChild(upperBodyTdAngle);
								upperBodyTr.appendChild(upperBodyTd2);
								upperBodyTr.appendChild(upperBodyTd3);
								upperBodyTr.appendChild(upperBodyTd4);
								upperBodyTr.appendChild(upperBodyTd5);
								worldLandmarksTable.appendChild(upperBodyTr);

								// ここに関節（左肘）の角度：Quaternion(x,y,z,w)を求める処理を追加
								const left_shoulder = result.worldLandmarks[0][11];
								const left_elbow = result.worldLandmarks[0][13];
								const left_wrist = result.worldLandmarks[0][15];
								// XY平面上での角度を求める
								const angle_XY = Math.atan2(left_wrist.y - left_elbow.y, left_wrist.x - left_elbow.x) - Math.atan2(left_elbow.y - left_shoulder.y, left_elbow.x - left_shoulder.x);
								// Quaternionを求める 小数点以下第7位で四捨五入する
								const leftElbowQuaternionXY = {
									x: 0,
									y: 0,
									// -1~1の範囲で、半周(180度)で1になるようにする
									z: -1 * Math.round(angle_XY / Math.PI * 1000000) / 1000000,
									w: 1,
								};
								// const worldLandmarksTable = document.getElementById("worldLandmarksTable");
								const leftElbowTr = document.createElement("tr");
								const leftElbowTd1 = document.createElement("td");
								const leftElbowTdAngle = document.createElement("td");
								const leftElbowTd2 = document.createElement("td");
								const leftElbowTd3 = document.createElement("td");
								const leftElbowTd4 = document.createElement("td");
								const leftElbowTd5 = document.createElement("td");
								leftElbowTd1.innerText = "左肘(20)";
								leftElbowTdAngle.innerText = Math.round(angle_XY / Math.PI * 1800) / 10;
								leftElbowTd2.innerText = leftElbowQuaternionXY.x;
								leftElbowTd3.innerText = leftElbowQuaternionXY.y;
								leftElbowTd4.innerText = leftElbowQuaternionXY.z;
								leftElbowTd5.innerText = leftElbowQuaternionXY.w;
								leftElbowTr.appendChild(leftElbowTd1);
								leftElbowTr.appendChild(leftElbowTdAngle);
								leftElbowTr.appendChild(leftElbowTd2);
								leftElbowTr.appendChild(leftElbowTd3);
								leftElbowTr.appendChild(leftElbowTd4);
								leftElbowTr.appendChild(leftElbowTd5);
								worldLandmarksTable.appendChild(leftElbowTr);
								// 同様に、関節（右肘）の角度：Quaternion(x,y,z,w)を求める処理を追加
								const right_shoulder = result.worldLandmarks[0][12];
								const right_elbow = result.worldLandmarks[0][14];
								const right_wrist = result.worldLandmarks[0][16];
								// XY平面上での角度を求める
								const angle_XY_right = Math.atan2(right_wrist.y - right_elbow.y, right_wrist.x - right_elbow.x) - Math.atan2(right_elbow.y - right_shoulder.y, right_elbow.x - right_shoulder.x);
								// Quaternionを求める
								const rightElbowQuaternionXY = {
									x: 0,
									y: 0,
									// 右側は左側の逆の角度になるので、-1をかける
									z: Math.round(angle_XY_right / Math.PI * 1000000) / 1000000,
									w: 1,
								};
								const rightElbowTr = document.createElement("tr");
								const rightElbowTd1 = document.createElement("td");
								const rightElbowTdAngle = document.createElement("td");
								const rightElbowTd2 = document.createElement("td");
								const rightElbowTd3 = document.createElement("td");
								const rightElbowTd4 = document.createElement("td");
								const rightElbowTd5 = document.createElement("td");
								rightElbowTd1.innerText = "右肘(52)";
								rightElbowTdAngle.innerText = Math.round(angle_XY_right / Math.PI * 1800) / 10;
								rightElbowTd2.innerText = rightElbowQuaternionXY.x;
								rightElbowTd3.innerText = rightElbowQuaternionXY.y;
								rightElbowTd4.innerText = rightElbowQuaternionXY.z;
								rightElbowTd5.innerText = rightElbowQuaternionXY.w;
								rightElbowTr.appendChild(rightElbowTd1);
								rightElbowTr.appendChild(rightElbowTdAngle);
								rightElbowTr.appendChild(rightElbowTd2);
								rightElbowTr.appendChild(rightElbowTd3);
								rightElbowTr.appendChild(rightElbowTd4);
								rightElbowTr.appendChild(rightElbowTd5);
								worldLandmarksTable.appendChild(rightElbowTr);
								// 関節（左肩）の角度：Quaternion(x,y,z,w)を求める処理を追加
								// 今回はrightShoulder-leftShoulder-leftElbow間の角度を求める
								const angle_XY_left_shoulder = Math.atan2(left_elbow.y - left_shoulder.y, left_elbow.x - left_shoulder.x) - Math.atan2(left_shoulder.y - right_shoulder.y, left_shoulder.x - right_shoulder.x);
								// Quaternionを求める
								const leftShoulderQuaternionXY = {
									x: 0,
									y: 0,
									// 肩は0 -> 0.3 , 0.5*PI -> -0.4 になるように加工
									z: Math.round((-1.4 * angle_XY_left_shoulder / Math.PI + 0.3) * 1000000) / 1000000,
									w: 1,
								};
								const leftShoulderTr = document.createElement("tr");
								const leftShoulderTd1 = document.createElement("td");
								const leftShoulderTdAngle = document.createElement("td");
								const leftShoulderTd2 = document.createElement("td");
								const leftShoulderTd3 = document.createElement("td");
								const leftShoulderTd4 = document.createElement("td");
								const leftShoulderTd5 = document.createElement("td");
								leftShoulderTd1.innerText = "左肩(18)";
								leftShoulderTdAngle.innerText = Math.round(angle_XY_left_shoulder / Math.PI * 1800) / 10;
								leftShoulderTd2.innerText = leftShoulderQuaternionXY.x;
								leftShoulderTd3.innerText = leftShoulderQuaternionXY.y;
								leftShoulderTd4.innerText = leftShoulderQuaternionXY.z;
								leftShoulderTd5.innerText = leftShoulderQuaternionXY.w;
								leftShoulderTr.appendChild(leftShoulderTd1);
								leftShoulderTr.appendChild(leftShoulderTdAngle);
								leftShoulderTr.appendChild(leftShoulderTd2);
								leftShoulderTr.appendChild(leftShoulderTd3);
								leftShoulderTr.appendChild(leftShoulderTd4);
								leftShoulderTr.appendChild(leftShoulderTd5);
								worldLandmarksTable.appendChild(leftShoulderTr);
								// 関節（右肩）の角度：Quaternion(x,y,z,w)を求める処理を追加
								// 今回はleftShoulder-rightShoulder-rightElbow間の角度を求める
								let angle_XY_right_shoulder = Math.atan2(right_elbow.y - right_shoulder.y, right_elbow.x - right_shoulder.x) - Math.atan2(right_shoulder.y - left_shoulder.y, right_shoulder.x - left_shoulder.x);
								if (angle_XY_right_shoulder > Math.PI) [
									// 範囲を-PI~PIにする
									angle_XY_right_shoulder -= 2 * Math.PI
								]
								// Quaternionを求める
								const rightShoulderQuaternionXY = {
									x: 0,
									y: 0,
									// 右肩は、0 -> -0.3 , -0.5*PI ->0.4 になるように加工
									z: -1 * Math.round((1.4 * angle_XY_right_shoulder / Math.PI + 0.3) * 1000000) / 1000000,
									w: 1,
								};
								const rightShoulderTr = document.createElement("tr");
								const rightShoulderTd1 = document.createElement("td");
								const rightShoulderTdAngle = document.createElement("td");
								const rightShoulderTd2 = document.createElement("td");
								const rightShoulderTd3 = document.createElement("td");
								const rightShoulderTd4 = document.createElement("td");
								const rightShoulderTd5 = document.createElement("td");
								rightShoulderTd1.innerText = "右肩(50)";
								rightShoulderTdAngle.innerText = Math.round(angle_XY_right_shoulder / Math.PI * 1800) / 10;
								rightShoulderTd2.innerText = rightShoulderQuaternionXY.x;
								rightShoulderTd3.innerText = rightShoulderQuaternionXY.y;
								rightShoulderTd4.innerText = rightShoulderQuaternionXY.z;
								rightShoulderTd5.innerText = rightShoulderQuaternionXY.w;
								rightShoulderTr.appendChild(rightShoulderTd1);
								rightShoulderTr.appendChild(rightShoulderTdAngle);
								rightShoulderTr.appendChild(rightShoulderTd2);
								rightShoulderTr.appendChild(rightShoulderTd3);
								rightShoulderTr.appendChild(rightShoulderTd4);
								rightShoulderTr.appendChild(rightShoulderTd5);
								worldLandmarksTable.appendChild(rightShoulderTr);

								// ここから数値の受け渡し処理
								Quaternions = {
									neck: neckQuaternionXY,
									upperBody: upperBodyQuaternionXY,
									leftElbow: leftElbowQuaternionXY,
									rightElbow: rightElbowQuaternionXY,
									leftShoulder: leftShoulderQuaternionXY,
									rightShoulder: rightShoulderQuaternionXY,
								};
								document.getElementById('switchSection').style.display = "";
								// rightElbowQuaternionXY;
								// leftElbowQuaternionXY;
								// rightShoulderQuaternionXY;
								// leftShoulderQuaternionXY;
								// neckQuaternionXY;
								// upperBodyQuaternionXY;



							}, 4000);
						}
					}
					console.log("canvas_after_result : ");
					console.log(result);
					result_after = result;

				});

			};
		});

		document.getElementById('switchSection').addEventListener('click', function () {
			// mmd-loader部分のjsを全て囲んでいる

			let stats;
			const vpds = [];

			let mesh, helper, ikHelper, physicsHelper;
			let camera, scene, renderer, effect;
			let new_vpds;

			const clock = new THREE.Clock();

			Ammo().then(async function (AmmoLib) {

				Ammo = AmmoLib;

				init();

			});


			function init() {

				const container = document.createElement('div');
				container.id = 'mmd-loader-container';
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
				camera.position.z = 30;

				// scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xffffff);

				const gridHelper = new THREE.PolarGridHelper(30, 0);
				gridHelper.position.y = - 10;
				scene.add(gridHelper);

				const ambient = new THREE.AmbientLight(0xaaaaaa, 3);
				scene.add(ambient);

				const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
				directionalLight.position.set(- 1, 1, 1).normalize();
				scene.add(directionalLight);

				//

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setAnimationLoop(animate);
				container.appendChild(renderer.domElement);

				effect = new OutlineEffect(renderer);

				// STATS

				stats = new Stats();
				container.appendChild(stats.dom);

				// model

				function onProgress(xhr) {

					if (xhr.lengthComputable) {

						const percentComplete = xhr.loaded / xhr.total * 100;
						console.log(Math.round(percentComplete, 2) + '% downloaded');

					}

				}


				// const modelFile = 'models/mmd/miku/miku_v2.pmd';
				const modelFile = 'three.js-master/examples/models/mmd/miku/miku_v2.pmd';
				// const vmdFiles = [ 'models/mmd/vmds/wavefile_v2.vmd' ];
				const vmdFiles = ['three.js-master/examples/models/mmd/vmds/wavefile_v2.vmd'];
				// const vpdFiles = [
				// 	'models/mmd/vpds/01.vpd',
				// 	'models/mmd/vpds/02.vpd',
				// 	'models/mmd/vpds/03.vpd',
				// 	'models/mmd/vpds/04.vpd',
				// 	'models/mmd/vpds/05.vpd',
				// 	'models/mmd/vpds/06.vpd',
				// 	'models/mmd/vpds/07.vpd',
				// 	'models/mmd/vpds/08.vpd',
				// 	//'models/mmd/vpds/09.vpd',
				// 	//'models/mmd/vpds/10.vpd',
				// 	'models/mmd/vpds/11.vpd'
				// ];
				// ここの1番目に追加する
				const vpdFiles = [
					'three.js-master/examples/models/mmd/vpds/default.vpd',
					// 'three.js-master/examples/models/mmd/vpds/01.vpd',
					// 'three.js-master/examples/models/mmd/vpds/02.vpd',
					// 'three.js-master/examples/models/mmd/vpds/03.vpd',
					// 'three.js-master/examples/models/mmd/vpds/04.vpd',
					// 'three.js-master/examples/models/mmd/vpds/05.vpd',
					// 'three.js-master/examples/models/mmd/vpds/06.vpd',
					// 'three.js-master/examples/models/mmd/vpds/07.vpd',
					// 'three.js-master/examples/models/mmd/vpds/08.vpd',
					// 'three.js-master/examples/models/mmd/vpds/11.vpd'
				]

				helper = new MMDAnimationHelper({
					afterglow: 2.0
				});

				const loader = new MMDLoader();

				// loadを使ってモデルを読み込む。onLoad functionでloadVpd()を呼び出す -> webgl_loader_mmd_pose.htmlから引用
				loader.load(modelFile, function (object) {

					mesh = object;
					mesh.position.y = - 10;
					scene.add(mesh);

					let vpdIndex = 0;

					function loadVpd() {

						const vpdFile = vpdFiles[vpdIndex];

						loader.loadVPD(vpdFile, false, function (vpd) {
							vpds.push(vpd);
							vpdIndex++;
							if (vpdIndex < vpdFiles.length) {
								loadVpd();
							} else {
								initGui();
							}
						}, onProgress, null);

					}
					loadVpd();
				}, onProgress, null);
				// loader.loadWithAnimation( modelFile, vmdFiles, function ( mmd ) {

				// 	mesh = mmd.mesh;
				// 	mesh.position.y = - 10;
				// 	scene.add( mesh );

				// 	helper.add( mesh, {
				// 		animation: mmd.animation,
				// 		physics: true
				// 	} );

				// 	ikHelper = helper.objects.get( mesh ).ikSolver.createHelper();
				// 	ikHelper.visible = false;
				// 	scene.add( ikHelper );

				// 	physicsHelper = helper.objects.get( mesh ).physics.createHelper();
				// 	physicsHelper.visible = false;
				// 	scene.add( physicsHelper );

				// 	initGui();

				// }, onProgress, null );

				const controls = new OrbitControls(camera, renderer.domElement);
				controls.minDistance = 10;
				controls.maxDistance = 100;

				window.addEventListener('resize', onWindowResize);

				function initGui() {
					// ここにparametersを作成　←webgl_raycaster_texture.htmlから引用
					const parameters = {
						'LeftShoulderX': 0.0,
						'LeftShoulderY': 0.0,
						'LeftShoulderZ': 0.0,
						'LeftShoulderW': 0.0
					};
					const api = {
						// 'pose': true,
						'animation': true,
						'ik': true,
						'outline': true,
						'physics': true,
						'show IK bones': false,
						'show rigid bodies': false
					};

					function getBaseName(s) {
						return s.slice(s.lastIndexOf('/') + 1);
					}

					const gui = new GUI();

					// ここにMediapipeの結果を反映させる
					console.log(Quaternions);
					if (leftShoulder in Quaternions) {
						vpds[0].bones[18].quaternion[0] = Quaternions.leftShoulder.x;
						vpds[0].bones[18].quaternion[1] = Quaternions.leftShoulder.y;
						vpds[0].bones[18].quaternion[2] = Quaternions.leftShoulder.z;
						vpds[0].bones[18].quaternion[3] = Quaternions.leftShoulder.w;
					}
					if (rightShoulder in Quaternions) {
						vpds[0].bones[50].quaternion[0] = Quaternions.rightShoulder.x;
						vpds[0].bones[50].quaternion[1] = Quaternions.rightShoulder.y;
						vpds[0].bones[50].quaternion[2] = Quaternions.rightShoulder.z;
						vpds[0].bones[50].quaternion[3] = Quaternions.rightShoulder.w;
					}
					if (leftElbow in Quaternions) {
						vpds[0].bones[20].quaternion[0] = Quaternions.leftElbow.x;
						vpds[0].bones[20].quaternion[1] = Quaternions.leftElbow.y;
						vpds[0].bones[20].quaternion[2] = Quaternions.leftElbow.z;
						vpds[0].bones[20].quaternion[3] = Quaternions.leftElbow.w;
					}
					if (rightElbow in Quaternions) {
						vpds[0].bones[52].quaternion[0] = Quaternions.rightElbow.x;
						vpds[0].bones[52].quaternion[1] = Quaternions.rightElbow.y;
						vpds[0].bones[52].quaternion[2] = Quaternions.rightElbow.z;
						vpds[0].bones[52].quaternion[3] = Quaternions.rightElbow.w;
					}
					if (neck in Quaternions) {
						vpds[0].bones[2].quaternion[0] = Quaternions.neck.x;
						vpds[0].bones[2].quaternion[1] = Quaternions.neck.y;
						vpds[0].bones[2].quaternion[2] = Quaternions.neck.z;
						vpds[0].bones[2].quaternion[3] = Quaternions.neck.w;
					}
					if (upperBody in Quaternions) {
						vpds[0].bones[1].quaternion[0] = Quaternions.upperBody.x;
						vpds[0].bones[1].quaternion[1] = Quaternions.upperBody.y;
						vpds[0].bones[1].quaternion[2] = Quaternions.upperBody.z;
						vpds[0].bones[1].quaternion[3] = Quaternions.upperBody.w;
					}
					helper.pose(mesh, vpds[0]);


					// ここにPosesのフォルダを作り、vpdsを操作できるようにする
					// const poses = gui.addFolder( 'Poses' );
					// const files = { default: -1 };
					// for ( let i = 0; i < vpds.length; i ++ ) {
					// 	files[ getBaseName( vpdFiles[ i ] ) ] = i;
					// }
					// poses.add( controls, 'pose', files ).onChange( onChangePose );

					// function onChangePose() {
					// 	const index = parseInt( controls.pose );
					// 	if ( index === -1 ) {
					// 		mesh.pose();
					// 	} else {
					// 		helper.pose( mesh, vpds[ index ] );
					// 	}
					// }
					// guiに項目を追加せず、helper.pose()を使ってposeを変更する
					try {
						console.log(vpds[0]);
						helper.pose(mesh, vpds[0]);
						// input群の数値が変更されたときに自動でhelper.pose()を呼び出す
						function changePose() {
							const poseName = document.getElementById("poseName").value;
							// poseNameが2桁の整数でない場合
							try {
								const poseNameInt = parseInt(poseName);
								if (poseNameInt < 0 || poseNameInt > 92) {
									console.log("無効なposeNameが入力されました : " + poseName);
									document.getElementById("poseName").value = 0;
									return;
								}
							} catch (e) {
								console.error(e);
								console.log("無効なposeNameが入力されました : " + poseName);
								document.getElementById("poseName").value = 0;
								return;
							}

							const poseX = document.getElementById("poseX").value;
							const poseY = document.getElementById("poseY").value;
							const poseZ = document.getElementById("poseZ").value;
							const poseW = document.getElementById("poseW").value;
							new_vpds = vpds[0];
							new_vpds.bones[parseInt(poseName)].quaternion[0] = parseFloat(poseX);
							new_vpds.bones[parseInt(poseName)].quaternion[1] = parseFloat(poseY);
							new_vpds.bones[parseInt(poseName)].quaternion[2] = parseFloat(poseZ);
							new_vpds.bones[parseInt(poseName)].quaternion[3] = parseFloat(poseW);
							// poseNameTextを更新
							document.getElementById("poseNameText").innerText = new_vpds.bones[parseInt(poseName)].name;
							helper.pose(mesh, new_vpds);
							console.log(new_vpds.bones[poseName]);
						}
						document.getElementById("poseName").addEventListener("input", changePose);
						document.getElementById("poseX").addEventListener("input", changePose);
						document.getElementById("poseY").addEventListener("input", changePose);
						document.getElementById("poseZ").addEventListener("input", changePose);
						document.getElementById("poseW").addEventListener("input", changePose);
						document.getElementById("resetPose").addEventListener("click", function () {
							for (let i = 0; i < new_vpds.bones.length; i++) {
								new_vpds.bones[i].quaternion[0] = 0;
								new_vpds.bones[i].quaternion[1] = 0;
								new_vpds.bones[i].quaternion[2] = 0;
								new_vpds.bones[i].quaternion[3] = 1;
							}
							document.getElementById("poseName").value = 17;
							document.getElementById("poseX").value = 0;
							document.getElementById("poseY").value = 0;
							document.getElementById("poseZ").value = 0;
							document.getElementById("poseW").value = 1;
							changePose();
						});
					} catch (e) {
						console.error(e);
					}



					// webgl-loader-mmdのloadWithAnimation()をload()に変更し、onLoadでinitPoses()を読み込み、そこでonChangePose()を設定した。結局vpdからposeの表示にはhelper( mesh , vpds[index] ):MMDAnimationHelperを使っているようだ

					// 最小0, 最大1, 0.01ずつ増減するparametersを作成
					// 失敗したので後日再挑戦

					// このposeが押されると、id="poseX"などの値を取得してposeを変更する
					// gui.add(api, 'pose').onChange(function () {
					// 	const poseName = document.getElementById("poseName").value;
					// 	// 0 ~ 92以外の値が入力された場合、0にする
					// 	if (poseName < 0 || poseName > 92) {
					// 		consile.log("無効なposeNameが入力されました : " + poseName);
					// 		poseName = 0;
					// 	}
					// 	const poseNameText = document.getElementById("poseNameText");
					// 	const poseX = document.getElementById("poseX").value;
					// 	const poseY = document.getElementById("poseY").value;
					// 	const poseZ = document.getElementById("poseZ").value;
					// 	const poseW = document.getElementById("poseW").value;
					// 	let new_vpds = vpds[0];
					// 	// vodsからposeNameを取得する
					// 	poseNameText.innerText = new_vpds.bones[parseInt(poseName)].name;
					// 	// new_vpdsのbone[17] 左肩の値を変更する
					// 	// {
					// 	//     "name": "左肩",
					// 	//     "translation": [0,0,0],
					// 	//     "quaternion": [0,0,0.661953,0.749545]
					// 	// }
					// 	new_vpds.bones[parseInt(poseName)].quaternion[0] = parseFloat(poseX);
					// 	new_vpds.bones[parseInt(poseName)].quaternion[1] = parseFloat(poseY);
					// 	new_vpds.bones[parseInt(poseName)].quaternion[2] = parseFloat(poseZ);
					// 	new_vpds.bones[parseInt(poseName)].quaternion[3] = parseFloat(poseW);
					// 	helper.pose(mesh, new_vpds);
					// 	console.log(new_vpds.bones[poseName]);
					// });

					gui.add(api, 'animation').onChange(function () {

						helper.enable('animation', api['animation']);

					});

					gui.add(api, 'ik').onChange(function () {

						helper.enable('ik', api['ik']);

					});

					gui.add(api, 'outline').onChange(function () {

						effect.enabled = api['outline'];

					});

					gui.add(api, 'physics').onChange(function () {

						helper.enable('physics', api['physics']);

					});

					gui.add(api, 'show IK bones').onChange(function () {

						ikHelper.visible = api['show IK bones'];

					});

					gui.add(api, 'show rigid bodies').onChange(function () {

						if (physicsHelper !== undefined) physicsHelper.visible = api['show rigid bodies'];

					});

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				effect.setSize(window.innerWidth, window.innerHeight);

			}

			//

			function animate() {

				stats.begin();
				render();
				stats.end();

			}

			function render() {

				helper.update(clock.getDelta());
				effect.render(scene, camera);

			}

		});

	</script>

</body>

</html>